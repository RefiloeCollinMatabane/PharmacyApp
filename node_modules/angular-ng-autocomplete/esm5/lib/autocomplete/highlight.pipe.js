/**
 * @fileoverview added by tsickle
 * Generated from: lib/autocomplete/highlight.pipe.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __assign } from "tslib";
import { Pipe } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
var HighlightPipe = /** @class */ (function () {
    function HighlightPipe() {
    }
    /**
     * @param {?} text
     * @param {?} search
     * @param {?=} searchKeyword
     * @return {?}
     */
    HighlightPipe.prototype.transform = /**
     * @param {?} text
     * @param {?} search
     * @param {?=} searchKeyword
     * @return {?}
     */
    function (text, search, searchKeyword) {
        /** @type {?} */
        var pattern = search.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
        pattern = pattern.split(' ').filter((/**
         * @param {?} t
         * @return {?}
         */
        function (t) {
            return t.length > 0;
        })).join('|');
        /** @type {?} */
        var regex = new RegExp(pattern, 'gi');
        if (!search) {
            return text;
        }
        if (searchKeyword) {
            /** @type {?} */
            var name_1 = text[searchKeyword].replace(regex, (/**
             * @param {?} match
             * @return {?}
             */
            function (match) { return "<b>" + match + "</b>"; }));
            // copy original object
            /** @type {?} */
            var text2 = __assign({}, text);
            // set bold value into searchKeyword of copied object
            text2[searchKeyword] = name_1;
            return text2;
        }
        else {
            return search ? text.replace(regex, (/**
             * @param {?} match
             * @return {?}
             */
            function (match) { return "<b>" + match + "</b>"; })) : text;
        }
    };
HighlightPipe.ngPipeDef = ɵngcc0.ɵɵdefinePipe({ name: "highlight", type: HighlightPipe, factory: function HighlightPipe_Factory(t) { return new (t || HighlightPipe)(); }, pure: true });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(HighlightPipe, [{
        type: Pipe,
        args: [{
                name: 'highlight'
            }]
    }], function () { return []; }, { transform: [] });
    return HighlightPipe;
}());
export { HighlightPipe };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3JjbWF0L0Ryb3Bib3gvUEMvRG93bmxvYWRzL1BoYXJtYWN5QXBwLW1hc3Rlci9QaGFybWFjeUFwcC1tYXN0ZXIvbm9kZV9tb2R1bGVzL2FuZ3VsYXItbmctYXV0b2NvbXBsZXRlL2VzbTUvbGliL2F1dG9jb21wbGV0ZS9oaWdobGlnaHQucGlwZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BbURNOzs7Ozs7O3VEQUtBIiwiZmlsZSI6ImhpZ2hsaWdodC5waXBlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGFkZGVkIGJ5IHRzaWNrbGVcbiAqIEdlbmVyYXRlZCBmcm9tOiBsaWIvYXV0b2NvbXBsZXRlL2hpZ2hsaWdodC5waXBlLnRzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsY29uc3RhbnRQcm9wZXJ0eSxleHRyYVJlcXVpcmUsbWlzc2luZ092ZXJyaWRlLG1pc3NpbmdSZXR1cm4sdW51c2VkUHJpdmF0ZU1lbWJlcnMsdXNlbGVzc0NvZGV9IGNoZWNrZWQgYnkgdHNjXG4gKi9cbmltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBQaXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG52YXIgSGlnaGxpZ2h0UGlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIaWdobGlnaHRQaXBlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHRleHRcbiAgICAgKiBAcGFyYW0gez99IHNlYXJjaFxuICAgICAqIEBwYXJhbSB7Pz19IHNlYXJjaEtleXdvcmRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIEhpZ2hsaWdodFBpcGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IC8qKlxuICAgICAqIEBwYXJhbSB7P30gdGV4dFxuICAgICAqIEBwYXJhbSB7P30gc2VhcmNoXG4gICAgICogQHBhcmFtIHs/PX0gc2VhcmNoS2V5d29yZFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gKHRleHQsIHNlYXJjaCwgc2VhcmNoS2V5d29yZCkge1xuICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgIHZhciBwYXR0ZXJuID0gc2VhcmNoLnJlcGxhY2UoL1tcXC1cXFtcXF1cXC9cXHtcXH1cXChcXClcXCpcXCtcXD9cXC5cXFxcXFxeXFwkXFx8XS9nLCAnXFxcXCQmJyk7XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNwbGl0KCcgJykuZmlsdGVyKCgvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIHQubGVuZ3RoID4gMDtcbiAgICAgICAgfSkpLmpvaW4oJ3wnKTtcbiAgICAgICAgLyoqIEB0eXBlIHs/fSAqL1xuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sICdnaScpO1xuICAgICAgICBpZiAoIXNlYXJjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlYXJjaEtleXdvcmQpIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7P30gKi9cbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0ZXh0W3NlYXJjaEtleXdvcmRdLnJlcGxhY2UocmVnZXgsICgvKipcbiAgICAgICAgICAgICAqIEBwYXJhbSB7P30gbWF0Y2hcbiAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gXCI8Yj5cIiArIG1hdGNoICsgXCI8L2I+XCI7IH0pKTtcbiAgICAgICAgICAgIC8vIGNvcHkgb3JpZ2luYWwgb2JqZWN0XG4gICAgICAgICAgICAvKiogQHR5cGUgez99ICovXG4gICAgICAgICAgICB2YXIgdGV4dDIgPSBfX2Fzc2lnbih7fSwgdGV4dCk7XG4gICAgICAgICAgICAvLyBzZXQgYm9sZCB2YWx1ZSBpbnRvIHNlYXJjaEtleXdvcmQgb2YgY29waWVkIG9iamVjdFxuICAgICAgICAgICAgdGV4dDJbc2VhcmNoS2V5d29yZF0gPSBuYW1lXzE7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoID8gdGV4dC5yZXBsYWNlKHJlZ2V4LCAoLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gez99IG1hdGNoXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIFwiPGI+XCIgKyBtYXRjaCArIFwiPC9iPlwiOyB9KSkgOiB0ZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIaWdobGlnaHRQaXBlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgIHsgdHlwZTogUGlwZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2hpZ2hsaWdodCdcbiAgICAgICAgICAgICAgICB9LF0gfVxuICAgIF07XG4gICAgcmV0dXJuIEhpZ2hsaWdodFBpcGU7XG59KCkpO1xuZXhwb3J0IHsgSGlnaGxpZ2h0UGlwZSB9O1xuIl19