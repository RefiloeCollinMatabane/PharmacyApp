{"version":3,"sources":["c:/Users/rcmat/Dropbox/PC/Downloads/PharmacyApp-master/PharmacyApp-master/node_modules/angular-ng-autocomplete/fesm2015/angular-ng-autocomplete.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;CAQC,sEAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAk7BD,aAsBC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAgOD,gCAKC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAQD,aAUC","file":"angular-ng-autocomplete.js","sourcesContent":["import { Component, EventEmitter, forwardRef, ViewEncapsulation, ElementRef, Renderer2, ViewChild, Input, Output, ContentChild, TemplateRef, Pipe, NgModule } from '@angular/core';\nimport { fromEvent } from 'rxjs';\nimport { map, filter, debounceTime } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete-lib.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AutocompleteLibComponent {\n    constructor() {\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n    }\n}\nAutocompleteLibComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'ng-autocomplete-lib',\n                template: `\n    <p>\n      autocomplete-lib works!\n    </p>\n  `\n            }] }\n];\n/** @nocollapse */\nAutocompleteLibComponent.ctorParameters = () => [];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete/autocomplete.component.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Keyboard events\n * @type {?}\n */\nconst isArrowUp = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => keyCode === 38);\nconst ɵ0 = isArrowUp;\n/** @type {?} */\nconst isArrowDown = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => keyCode === 40);\nconst ɵ1 = isArrowDown;\n/** @type {?} */\nconst isArrowUpDown = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => isArrowUp(keyCode) || isArrowDown(keyCode));\nconst ɵ2 = isArrowUpDown;\n/** @type {?} */\nconst isEnter = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => keyCode === 13);\nconst ɵ3 = isEnter;\n/** @type {?} */\nconst isBackspace = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => keyCode === 8);\nconst ɵ4 = isBackspace;\n/** @type {?} */\nconst isDelete = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => keyCode === 46);\nconst ɵ5 = isDelete;\n/** @type {?} */\nconst isESC = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => keyCode === 27);\nconst ɵ6 = isESC;\n/** @type {?} */\nconst isTab = (/**\n * @param {?} keyCode\n * @return {?}\n */\nkeyCode => keyCode === 9);\nconst ɵ7 = isTab;\nclass AutocompleteComponent {\n    /**\n     * @param {?} elementRef\n     * @param {?} renderer\n     */\n    constructor(elementRef, renderer) {\n        this.renderer = renderer;\n        // input events\n        this.query = ''; // search query\n        // search query\n        this.filteredList = []; // list of items\n        // list of items\n        this.historyList = []; // list of history items\n        // list of history items\n        this.isHistoryListVisible = true;\n        this.selectedIdx = -1;\n        this.toHighlight = '';\n        this.notFound = false;\n        this.isFocused = false;\n        this.isOpen = false;\n        this.isScrollToEnd = false;\n        this.overlay = false;\n        this.manualOpen = undefined;\n        this.manualClose = undefined;\n        // @Inputs\n        /**\n         * Data of items list.\n         * It can be array of strings or array of objects.\n         */\n        this.data = [];\n        // keyword to filter the list\n        this.placeHolder = ''; // input placeholder\n        // input placeholder\n        this.heading = '';\n        /**\n         * Heading text of history list.\n         * If it is null then history heading is hidden.\n         */\n        this.historyHeading = 'Recently selected';\n        this.historyListMaxNumber = 15; // maximum number of items in the history list.\n        // maximum number of items in the history list.\n        this.notFoundText = 'Not found'; // set custom text when filter returns empty result\n        // input disable/enable\n        /**\n         * The minimum number of characters the user must type before a search is performed.\n         */\n        this.minQueryLength = 1;\n        // @Output events\n        /**\n         * Event that is emitted whenever an item from the list is selected.\n         */\n        this.selected = new EventEmitter();\n        /**\n         * Event that is emitted whenever an input is changed.\n         */\n        this.inputChanged = new EventEmitter();\n        /**\n         * Event that is emitted whenever an input is focused.\n         */\n        this.inputFocused = new EventEmitter();\n        /**\n         * Event that is emitted whenever an input is cleared.\n         */\n        this.inputCleared = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is opened.\n         */\n        this.opened = new EventEmitter();\n        /**\n         * Event that is emitted when the autocomplete panel is closed.\n         */\n        this.closed = new EventEmitter();\n        /**\n         * Event that is emitted when scrolled to the end of items.\n         */\n        this.scrolledToEnd = new EventEmitter();\n        /**\n         * Propagates new value when model changes\n         */\n        this.propagateChange = (/**\n         * @return {?}\n         */\n        () => {\n        });\n        this.elementRef = elementRef;\n    }\n    /**\n     * Writes a new value from the form model into the view,\n     * Updates model\n     * @param {?} value\n     * @return {?}\n     */\n    writeValue(value) {\n        this.query = value;\n    }\n    /**\n     * Registers a handler that is called when something in the view has changed\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnChange(fn) {\n        this.propagateChange = fn;\n    }\n    /**\n     * Registers a handler specifically for when a control receives a touch event\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnTouched(fn) {\n    }\n    /**\n     * Event that is called when the value of an input element is changed\n     * @param {?} event\n     * @return {?}\n     */\n    onChange(event) {\n        this.propagateChange(event.target.value);\n    }\n    /**\n     * Event that is called when the control status changes to or from DISABLED\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    setDisabledState(isDisabled) {\n        this.disabled = isDisabled;\n    }\n    /**\n     * @return {?}\n     */\n    ngOnInit() {\n        this.setInitialValue(this.initialValue);\n    }\n    /**\n     * @return {?}\n     */\n    ngAfterViewInit() {\n        this.initEventStream();\n        this.handleScroll();\n    }\n    /**\n     * Set initial value\n     * @param {?} value\n     * @return {?}\n     */\n    setInitialValue(value) {\n        if (this.initialValue) {\n            this.select(value);\n        }\n    }\n    /**\n     * Update search results\n     * @param {?} changes\n     * @return {?}\n     */\n    ngOnChanges(changes) {\n        if (changes &&\n            changes.data &&\n            Array.isArray(changes.data.currentValue)) {\n            this.handleItemsChange();\n            if (!changes.data.firstChange && this.isFocused) {\n                this.handleOpen();\n            }\n        }\n    }\n    /**\n     * Items change\n     * @return {?}\n     */\n    handleItemsChange() {\n        this.isScrollToEnd = false;\n        if (!this.isOpen) {\n            return;\n        }\n        this.filteredList = this.data;\n        this.notFound = !this.filteredList || this.filteredList.length === 0;\n    }\n    /**\n     * Filter data\n     * @return {?}\n     */\n    filterList() {\n        this.selectedIdx = -1;\n        this.initSearchHistory();\n        if (this.query != null && this.data) {\n            this.toHighlight = this.query;\n            this.filteredList = this.data.filter((/**\n             * @param {?} item\n             * @return {?}\n             */\n            (item) => {\n                if (typeof item === 'string') {\n                    // string logic, check equality of strings\n                    return item.toLowerCase().indexOf(this.query.toLowerCase()) > -1;\n                }\n                else if (typeof item === 'object' && item.constructor === Object) {\n                    // object logic, check property equality\n                    return item[this.searchKeyword].toLowerCase().indexOf(this.query.toLowerCase()) > -1;\n                }\n            }));\n        }\n        else {\n            this.notFound = false;\n        }\n    }\n    /**\n     * Check type of item in the list.\n     * @param {?} item\n     * @return {?}\n     */\n    isType(item) {\n        return typeof item === 'string';\n    }\n    /**\n     * Select item in the list.\n     * @param {?} item\n     * @return {?}\n     */\n    select(item) {\n        this.query = !this.isType(item) ? item[this.searchKeyword] : item;\n        this.isOpen = true;\n        this.overlay = false;\n        this.selected.emit(item);\n        this.propagateChange(item);\n        if (this.initialValue) {\n            // check if history already exists in localStorage and then update\n            /** @type {?} */\n            const history = window.localStorage.getItem(`${this.historyIdentifier}`);\n            if (history) {\n                /** @type {?} */\n                let existingHistory = JSON.parse(localStorage[`${this.historyIdentifier}`]);\n                if (!(existingHistory instanceof Array))\n                    existingHistory = [];\n                // check if selected item exists in existingHistory\n                if (!existingHistory.some((/**\n                 * @param {?} existingItem\n                 * @return {?}\n                 */\n                (existingItem) => !this.isType(existingItem)\n                    ? existingItem[this.searchKeyword] == item[this.searchKeyword] : existingItem == item))) {\n                    existingHistory.unshift(item);\n                    localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(existingHistory));\n                    // check if items don't exceed max allowed number\n                    if (existingHistory.length >= this.historyListMaxNumber) {\n                        existingHistory.splice(existingHistory.length - 1, 1);\n                        localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(existingHistory));\n                    }\n                }\n                else {\n                    // if selected item exists in existingHistory swap to top in array\n                    if (!this.isType(item)) {\n                        // object logic\n                        /** @type {?} */\n                        const copiedExistingHistory = existingHistory.slice();\n                        // copy original existingHistory array\n                        /** @type {?} */\n                        const selectedIndex = copiedExistingHistory.map((/**\n                         * @param {?} el\n                         * @return {?}\n                         */\n                        (el) => el[this.searchKeyword])).indexOf(item[this.searchKeyword]);\n                        copiedExistingHistory.splice(selectedIndex, 1);\n                        copiedExistingHistory.splice(0, 0, item);\n                        localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(copiedExistingHistory));\n                    }\n                    else {\n                        // string logic\n                        /** @type {?} */\n                        const copiedExistingHistory = existingHistory.slice();\n                        copiedExistingHistory.splice(copiedExistingHistory.indexOf(item), 1);\n                        copiedExistingHistory.splice(0, 0, item);\n                        localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(copiedExistingHistory));\n                    }\n                }\n            }\n            else {\n                this.saveHistory(item);\n            }\n        }\n        else {\n            this.saveHistory(item);\n        }\n        this.handleClose();\n    }\n    /**\n     * Document click\n     * @param {?} e event\n     * @return {?}\n     */\n    handleClick(e) {\n        /** @type {?} */\n        let clickedComponent = e.target;\n        /** @type {?} */\n        let inside = false;\n        do {\n            if (clickedComponent === this.elementRef.nativeElement) {\n                inside = true;\n                if (this.filteredList.length) {\n                    this.handleOpen();\n                }\n            }\n            clickedComponent = clickedComponent.parentNode;\n        } while (clickedComponent);\n        if (!inside) {\n            this.handleClose();\n        }\n    }\n    /**\n     * Handle body overlay\n     * @return {?}\n     */\n    handleOverlay() {\n        this.overlay = false;\n    }\n    /**\n     * Scroll items\n     * @return {?}\n     */\n    handleScroll() {\n        this.renderer.listen(this.filteredListElement.nativeElement, 'scroll', (/**\n         * @return {?}\n         */\n        () => {\n            this.scrollToEnd();\n        }));\n    }\n    /**\n     * Define panel state\n     * @param {?} event\n     * @return {?}\n     */\n    setPanelState(event) {\n        if (event) {\n            event.stopPropagation();\n        }\n        // If controls are untouched\n        if (typeof this.manualOpen === 'undefined'\n            && typeof this.manualClose === 'undefined') {\n            this.isOpen = false;\n            this.handleOpen();\n        }\n        // If one of the controls is untouched and other is deactivated\n        if (typeof this.manualOpen === 'undefined'\n            && this.manualClose === false\n            || typeof this.manualClose === 'undefined'\n                && this.manualOpen === false) {\n            this.isOpen = false;\n            this.handleOpen();\n        }\n        // if controls are touched but both are deactivated\n        if (this.manualOpen === false && this.manualClose === false) {\n            this.isOpen = false;\n            this.handleOpen();\n        }\n        // if open control is touched and activated\n        if (this.manualOpen) {\n            this.isOpen = false;\n            this.handleOpen();\n            this.manualOpen = false;\n        }\n        // if close control is touched and activated\n        if (this.manualClose) {\n            this.isOpen = true;\n            this.handleClose();\n            this.manualClose = false;\n        }\n    }\n    /**\n     * Manual controls\n     * @return {?}\n     */\n    open() {\n        this.manualOpen = true;\n        this.isOpen = false;\n        this.handleOpen();\n    }\n    /**\n     * @return {?}\n     */\n    close() {\n        this.manualClose = true;\n        this.isOpen = true;\n        this.handleClose();\n    }\n    /**\n     * @return {?}\n     */\n    focus() {\n        this.handleFocus(event);\n    }\n    /**\n     * @return {?}\n     */\n    clear() {\n        this.remove(event);\n    }\n    /**\n     * Remove search query\n     * @param {?} e\n     * @return {?}\n     */\n    remove(e) {\n        e.stopPropagation();\n        this.query = '';\n        this.inputCleared.emit();\n        this.propagateChange(this.query);\n        this.setPanelState(e);\n    }\n    /**\n     * Initialize historyList search\n     * @return {?}\n     */\n    initSearchHistory() {\n        this.isHistoryListVisible = false;\n        if (this.historyIdentifier && !this.query) {\n            /** @type {?} */\n            const history = window.localStorage.getItem(`${this.historyIdentifier}`);\n            if (history) {\n                this.isHistoryListVisible = true;\n                this.filteredList = [];\n                this.historyList = history ? JSON.parse(history) : [];\n            }\n            else {\n                this.isHistoryListVisible = false;\n            }\n        }\n        else {\n            this.isHistoryListVisible = false;\n        }\n    }\n    /**\n     * @return {?}\n     */\n    handleOpen() {\n        if (this.isOpen || this.isOpen && !this.isLoading) {\n            return;\n        }\n        // If data exists\n        if (this.data && this.data.length) {\n            this.isOpen = true;\n            this.overlay = true;\n            this.filterList();\n            this.opened.emit();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    handleClose() {\n        if (!this.isOpen) {\n            this.isFocused = false;\n            return;\n        }\n        this.isOpen = false;\n        this.overlay = false;\n        this.filteredList = [];\n        this.selectedIdx = -1;\n        this.notFound = false;\n        this.isHistoryListVisible = false;\n        this.isFocused = false;\n        this.closed.emit();\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    handleFocus(e) {\n        this.searchInput.nativeElement.focus();\n        if (this.isFocused) {\n            return;\n        }\n        this.inputFocused.emit(e);\n        // if data exists then open\n        if (this.data && this.data.length) {\n            this.setPanelState(event);\n        }\n        this.isFocused = true;\n    }\n    /**\n     * @return {?}\n     */\n    scrollToEnd() {\n        if (this.isScrollToEnd) {\n            return;\n        }\n        /** @type {?} */\n        const scrollTop = this.filteredListElement.nativeElement\n            .scrollTop;\n        /** @type {?} */\n        const scrollHeight = this.filteredListElement.nativeElement\n            .scrollHeight;\n        /** @type {?} */\n        const elementHeight = this.filteredListElement.nativeElement\n            .clientHeight;\n        /** @type {?} */\n        const atBottom = scrollHeight === scrollTop + elementHeight;\n        if (atBottom) {\n            this.scrolledToEnd.emit();\n            this.isScrollToEnd = true;\n        }\n    }\n    /**\n     * Initialize keyboard events\n     * @return {?}\n     */\n    initEventStream() {\n        this.inputKeyUp$ = fromEvent(this.searchInput.nativeElement, 'keyup').pipe(map((/**\n         * @param {?} e\n         * @return {?}\n         */\n        (e) => e)));\n        this.inputKeyDown$ = fromEvent(this.searchInput.nativeElement, 'keydown').pipe(map((/**\n         * @param {?} e\n         * @return {?}\n         */\n        (e) => e)));\n        this.listenEventStream();\n    }\n    /**\n     * Listen keyboard events\n     * @return {?}\n     */\n    listenEventStream() {\n        // key up event\n        this.inputKeyUp$\n            .pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => !isArrowUpDown(e.keyCode) &&\n            !isEnter(e.keyCode) &&\n            !isESC(e.keyCode) &&\n            !isTab(e.keyCode))), debounceTime(this.debounceTime)).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            this.onKeyUp(e);\n        }));\n        // cursor up & down\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => isArrowUpDown(e.keyCode)))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            e.preventDefault();\n            this.onFocusItem(e);\n        }));\n        // enter keyup\n        this.inputKeyUp$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => isEnter(e.keyCode)))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            //this.onHandleEnter();\n        }));\n        // enter keydown\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => isEnter(e.keyCode)))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            this.onHandleEnter();\n        }));\n        // ESC\n        this.inputKeyUp$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => isESC(e.keyCode)), debounceTime(100))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            this.onEsc();\n        }));\n        // TAB\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => isTab(e.keyCode)))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            this.onTab();\n        }));\n        // delete\n        this.inputKeyDown$.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => isBackspace(e.keyCode) || isDelete(e.keyCode)))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            this.onDelete();\n        }));\n    }\n    /**\n     * on keyup == when input changed\n     * @param {?} e event\n     * @return {?}\n     */\n    onKeyUp(e) {\n        this.notFound = false; // search results are unknown while typing\n        // if input is empty\n        if (!this.query) {\n            this.notFound = false;\n            this.inputChanged.emit(e.target.value);\n            this.inputCleared.emit();\n            //this.filterList();\n            this.setPanelState(e);\n        }\n        // note that '' can be a valid query\n        if (!this.query && this.query !== '') {\n            return;\n        }\n        // if query >= to minQueryLength\n        if (this.query.length >= this.minQueryLength) {\n            this.inputChanged.emit(e.target.value);\n            this.filterList();\n            // If no results found\n            if (!this.filteredList.length && !this.isLoading) {\n                this.notFoundText ? this.notFound = true : this.notFound = false;\n            }\n        }\n    }\n    /**\n     * Keyboard arrow top and arrow bottom\n     * @param {?} e event\n     * @return {?}\n     */\n    onFocusItem(e) {\n        // move arrow up and down on filteredList or historyList\n        if (!this.historyList.length || !this.isHistoryListVisible) {\n            // filteredList\n            /** @type {?} */\n            const totalNumItem = this.filteredList.length;\n            if (e.key === 'ArrowDown') {\n                /** @type {?} */\n                let sum = this.selectedIdx;\n                sum = (this.selectedIdx === null) ? 0 : sum + 1;\n                this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n            else if (e.key === 'ArrowUp') {\n                if (this.selectedIdx == -1) {\n                    this.selectedIdx = 0;\n                }\n                this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n        }\n        else {\n            // historyList\n            /** @type {?} */\n            const totalNumItem = this.historyList.length;\n            if (e.key === 'ArrowDown') {\n                /** @type {?} */\n                let sum = this.selectedIdx;\n                sum = (this.selectedIdx === null) ? 0 : sum + 1;\n                this.selectedIdx = (totalNumItem + sum) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n            else if (e.key === 'ArrowUp') {\n                if (this.selectedIdx == -1) {\n                    this.selectedIdx = 0;\n                }\n                this.selectedIdx = (totalNumItem + this.selectedIdx - 1) % totalNumItem;\n                this.scrollToFocusedItem(this.selectedIdx);\n            }\n        }\n    }\n    /**\n     * Scroll to focused item\n     * * \\@param index\n     * @param {?} index\n     * @return {?}\n     */\n    scrollToFocusedItem(index) {\n        /** @type {?} */\n        let listElement = null;\n        // Define list element\n        if (!this.historyList.length || !this.isHistoryListVisible) {\n            // filteredList element\n            listElement = this.filteredListElement.nativeElement;\n        }\n        else {\n            // historyList element\n            listElement = this.historyListElement.nativeElement;\n        }\n        /** @type {?} */\n        const items = Array.prototype.slice.call(listElement.childNodes).filter((/**\n         * @param {?} node\n         * @return {?}\n         */\n        (node) => {\n            if (node.nodeType === 1) {\n                // if node is element\n                return node.className.includes('item');\n            }\n            else {\n                return false;\n            }\n        }));\n        if (!items.length) {\n            return;\n        }\n        /** @type {?} */\n        const listHeight = listElement.offsetHeight;\n        /** @type {?} */\n        const itemHeight = items[index].offsetHeight;\n        /** @type {?} */\n        const visibleTop = listElement.scrollTop;\n        /** @type {?} */\n        const visibleBottom = listElement.scrollTop + listHeight - itemHeight;\n        /** @type {?} */\n        const targetPosition = items[index].offsetTop;\n        if (targetPosition < visibleTop) {\n            listElement.scrollTop = targetPosition;\n        }\n        if (targetPosition > visibleBottom) {\n            listElement.scrollTop = targetPosition - listHeight + itemHeight;\n        }\n    }\n    /**\n     * Select item on enter click\n     * @return {?}\n     */\n    onHandleEnter() {\n        // click enter to choose item from filteredList or historyList\n        if (this.selectedIdx > -1) {\n            if (!this.historyList.length || !this.isHistoryListVisible) {\n                // filteredList\n                this.query = !this.isType(this.filteredList[this.selectedIdx])\n                    ? this.filteredList[this.selectedIdx][this.searchKeyword]\n                    : this.filteredList[this.selectedIdx];\n                this.saveHistory(this.filteredList[this.selectedIdx]);\n                this.select(this.filteredList[this.selectedIdx]);\n            }\n            else {\n                // historyList\n                this.query = !this.isType(this.historyList[this.selectedIdx])\n                    ? this.historyList[this.selectedIdx][this.searchKeyword]\n                    : this.historyList[this.selectedIdx];\n                this.saveHistory(this.historyList[this.selectedIdx]);\n                this.select(this.historyList[this.selectedIdx]);\n            }\n        }\n        this.isHistoryListVisible = false;\n        this.handleClose();\n    }\n    /**\n     * Esc click\n     * @return {?}\n     */\n    onEsc() {\n        this.searchInput.nativeElement.blur();\n        this.handleClose();\n    }\n    /**\n     * Tab click\n     * @return {?}\n     */\n    onTab() {\n        this.searchInput.nativeElement.blur();\n        this.handleClose();\n    }\n    /**\n     * Delete click\n     * @return {?}\n     */\n    onDelete() {\n        // panel is open on delete\n        this.isOpen = true;\n    }\n    /**\n     * Select item to save in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n    saveHistory(selected) {\n        if (this.historyIdentifier) {\n            // check if selected item exists in historyList\n            if (!this.historyList.some((/**\n             * @param {?} item\n             * @return {?}\n             */\n            (item) => !this.isType(item)\n                ? item[this.searchKeyword] == selected[this.searchKeyword] : item == selected))) {\n                this.saveHistoryToLocalStorage([selected, ...this.historyList]);\n                // check if items don't exceed max allowed number\n                if (this.historyList.length >= this.historyListMaxNumber) {\n                    this.historyList.splice(this.historyList.length - 1, 1);\n                    this.saveHistoryToLocalStorage([selected, ...this.historyList]);\n                }\n            }\n            else {\n                // if selected item exists in historyList swap to top in array\n                if (!this.isType(selected)) {\n                    // object logic\n                    /** @type {?} */\n                    const copiedHistoryList = this.historyList.slice();\n                    // copy original historyList array\n                    /** @type {?} */\n                    const selectedIndex = copiedHistoryList.map((/**\n                     * @param {?} item\n                     * @return {?}\n                     */\n                    (item) => item[this.searchKeyword])).indexOf(selected[this.searchKeyword]);\n                    copiedHistoryList.splice(selectedIndex, 1);\n                    copiedHistoryList.splice(0, 0, selected);\n                    this.saveHistoryToLocalStorage([...copiedHistoryList]);\n                }\n                else {\n                    // string logic\n                    /** @type {?} */\n                    const copiedHistoryList = this.historyList.slice();\n                    copiedHistoryList.splice(this.historyList.indexOf(selected), 1);\n                    copiedHistoryList.splice(0, 0, selected);\n                    this.saveHistoryToLocalStorage([...copiedHistoryList]);\n                }\n            }\n        }\n    }\n    /**\n     * Save item in localStorage\n     * @param {?} selected\n     * @return {?}\n     */\n    saveHistoryToLocalStorage(selected) {\n        window.localStorage.setItem(`${this.historyIdentifier}`, JSON.stringify(selected));\n    }\n    /**\n     * Remove item from localStorage\n     * @param {?} index\n     * @param {?} e event\n     * @return {?}\n     */\n    removeHistoryItem(index, e) {\n        e.stopPropagation();\n        this.historyList = this.historyList.filter((/**\n         * @param {?} v\n         * @param {?} i\n         * @return {?}\n         */\n        (v, i) => i !== index));\n        this.saveHistoryToLocalStorage(this.historyList);\n        if (this.historyList.length == 0) {\n            window.localStorage.removeItem(`${this.historyIdentifier}`);\n            this.filterList();\n        }\n    }\n    /**\n     * Reset localStorage\n     * @param {?} e event\n     * @return {?}\n     */\n    resetHistoryList(e) {\n        e.stopPropagation();\n        this.historyList = [];\n        window.localStorage.removeItem(`${this.historyIdentifier}`);\n        this.filterList();\n    }\n}\nAutocompleteComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'ng-autocomplete',\n                template: \"<div class=\\\"autocomplete-container\\\"\\n     [ngClass]=\\\"{ 'active': isOpen}\\\">\\n  <div class=\\\"input-container\\\">\\n    <input #searchInput type=\\\"text\\\" placeholder={{placeHolder}}\\n           [(ngModel)]=query\\n           (input)=\\\"onChange($event)\\\"\\n           (focus)=handleFocus($event)\\n           [disabled]=\\\"disabled\\\">\\n    <div class=\\\"x\\\" *ngIf=\\\"query && !isLoading && !disabled\\\" (click)=\\\"remove($event)\\\">\\n      <i class=\\\"material-icons\\\">close</i>\\n    </div>\\n    <!--Loading mask-->\\n    <div class=\\\"sk-fading-circle\\\" *ngIf=\\\"isLoading\\\">\\n      <div class=\\\"sk-circle1 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle2 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle3 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle4 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle5 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle6 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle7 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle8 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle9 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle10 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle11 sk-circle\\\"></div>\\n      <div class=\\\"sk-circle12 sk-circle\\\"></div>\\n    </div>\\n  </div>\\n\\n  <!--FilteredList items-->\\n  <div class=\\\"suggestions-container\\\"\\n       [ngClass]=\\\"{ 'is-hidden': isHistoryListVisible, 'is-visible': !isHistoryListVisible}\\\">\\n    <!--FilteredList heading-->\\n    <div class=\\\"heading\\\" *ngIf=\\\"filteredList.length > 0 && heading\\\">\\n      <div class=\\\"text\\\">{{heading}}</div>\\n    </div>\\n\\n    <ul #filteredListElement>\\n      <li *ngFor=\\\"let item of filteredList; let idx = index\\\" class=\\\"item\\\">\\n        <!--string logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='isType(item)'\\n             (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate;  context: { $implicit: item | highlight: toHighlight }\\\">\\n          </ng-container>\\n        </div>\\n        <!--object logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='!isType(item)'\\n             (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item | highlight: toHighlight : searchKeyword }\\\">\\n          </ng-container>\\n        </div>\\n      </li>\\n    </ul>\\n  </div>\\n\\n  <!--HistoryList items-->\\n  <div class=\\\"suggestions-container\\\"\\n       [ngClass]=\\\"{ 'is-hidden': !isHistoryListVisible, 'is-visible': isHistoryListVisible}\\\">\\n    <!--HistoryList heading-->\\n    <div class=\\\"heading\\\" *ngIf=\\\"historyList.length > 0 && historyHeading\\\">\\n      <div class=\\\"text\\\">{{historyHeading}}</div>\\n      <div class=\\\"x\\\" (click)=\\\"resetHistoryList($event)\\\">\\n        <i class=\\\"material-icons\\\">delete</i>\\n      </div>\\n    </div>\\n\\n    <ul #historyListElement>\\n      <li *ngFor=\\\"let item of historyList; let idx = index\\\" class=\\\"item\\\">\\n        <!--string logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='isType(item)' (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate;  context: { $implicit: item }\\\">\\n          </ng-container>\\n        </div>\\n        <!--object logic-->\\n        <div [class.complete-selected]=\\\"idx === selectedIdx\\\" *ngIf='!isType(item)' (click)=\\\"select(item)\\\">\\n          <ng-container\\n            *ngTemplateOutlet=\\\"itemTemplate; context: { $implicit: item }\\\">\\n          </ng-container>\\n        </div>\\n        <div class=\\\"x\\\" (click)=\\\"removeHistoryItem(idx, $event)\\\">\\n          <i class=\\\"material-icons\\\">close</i>\\n        </div>\\n      </li>\\n    </ul>\\n  </div>\\n\\n  <!--Not found-->\\n  <div class=\\\"not-found\\\" *ngIf=\\\"isLoading ? !isLoading && notFound : notFound\\\">\\n    <ng-container\\n      *ngTemplateOutlet=\\\"notFoundTemplate;  context: { $implicit: notFoundText  }\\\">\\n    </ng-container>\\n  </div>\\n</div>\\n<div class=\\\"overlay\\\" *ngIf=\\\"overlay\\\" (click)=\\\"handleOverlay()\\\"></div>\\n\",\n                providers: [\n                    {\n                        provide: NG_VALUE_ACCESSOR,\n                        useExisting: forwardRef((/**\n                         * @return {?}\n                         */\n                        () => AutocompleteComponent)),\n                        multi: true\n                    }\n                ],\n                encapsulation: ViewEncapsulation.None,\n                host: {\n                    '(document:click)': 'handleClick($event)',\n                    'class': 'ng-autocomplete'\n                },\n                styles: [\"@import url(https://fonts.googleapis.com/icon?family=Material+Icons);.ng-autocomplete{width:600px}.autocomplete-container{box-shadow:0 1px 3px 0 rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 2px 1px -1px rgba(0,0,0,.12);position:relative;overflow:visible;height:40px}.autocomplete-container .input-container input{font-size:14px;box-sizing:border-box;border:none;box-shadow:none;outline:0;background-color:#fff;color:rgba(0,0,0,.87);width:100%;padding:0 15px;line-height:40px;height:40px}.autocomplete-container .input-container input:disabled{background-color:#eee;color:#666}.autocomplete-container .input-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.autocomplete-container .input-container .x i{color:rgba(0,0,0,.54);font-size:22px;vertical-align:middle}.autocomplete-container .suggestions-container{position:absolute;width:100%;background:#fff;height:auto;box-shadow:0 2px 5px rgba(0,0,0,.25);box-sizing:border-box}.autocomplete-container .suggestions-container ul{padding:0;margin:0;max-height:240px;overflow-y:auto}.autocomplete-container .suggestions-container ul li{position:relative;list-style:none;padding:0;margin:0;cursor:pointer}.autocomplete-container .suggestions-container ul li a{padding:14px 15px;display:block;text-decoration:none;cursor:pointer;color:rgba(0,0,0,.87);font-size:15px}.autocomplete-container .suggestions-container .complete-selected,.autocomplete-container .suggestions-container ul li:hover{background-color:rgba(158,158,158,.18)}.autocomplete-container .suggestions-container .heading{position:relative;padding:10px 15px;border:1px solid #f1f1f1}.autocomplete-container .suggestions-container .heading .text{font-size:.85em}.autocomplete-container .suggestions-container .x{position:absolute;right:10px;margin:auto;cursor:pointer;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.autocomplete-container .suggestions-container .x i{color:rgba(0,0,0,.54);font-size:18px;vertical-align:middle}.autocomplete-container .suggestions-container.is-hidden{visibility:hidden}.autocomplete-container .suggestions-container.is-visible{visibility:visible}.autocomplete-container .not-found{padding:0 .75em;border:1px solid #f1f1f1;background:#fff}.autocomplete-container .not-found div{padding:.4em 0;font-size:.95em;line-height:1.4;border-bottom:1px solid rgba(230,230,230,.7)}.autocomplete-container.active{z-index:999}.highlight{font-weight:700}.overlay{position:absolute;background-color:transparent;width:100%;height:100%;top:0;right:0;bottom:0;left:0;z-index:50}input[type=text]::-ms-clear{display:none}.sk-fading-circle{width:20px;height:20px;position:absolute;right:10px;top:0;bottom:0;margin:auto}.sk-fading-circle .sk-circle{width:100%;height:100%;position:absolute;left:0;top:0}.sk-fading-circle .sk-circle:before{content:\\\"\\\";display:block;margin:0 auto;width:15%;height:15%;background-color:#333;border-radius:100%;-webkit-animation:1.2s ease-in-out infinite both sk-circleFadeDelay;animation:1.2s ease-in-out infinite both sk-circleFadeDelay}.sk-fading-circle .sk-circle2{-webkit-transform:rotate(30deg);transform:rotate(30deg)}.sk-fading-circle .sk-circle3{-webkit-transform:rotate(60deg);transform:rotate(60deg)}.sk-fading-circle .sk-circle4{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.sk-fading-circle .sk-circle5{-webkit-transform:rotate(120deg);transform:rotate(120deg)}.sk-fading-circle .sk-circle6{-webkit-transform:rotate(150deg);transform:rotate(150deg)}.sk-fading-circle .sk-circle7{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.sk-fading-circle .sk-circle8{-webkit-transform:rotate(210deg);transform:rotate(210deg)}.sk-fading-circle .sk-circle9{-webkit-transform:rotate(240deg);transform:rotate(240deg)}.sk-fading-circle .sk-circle10{-webkit-transform:rotate(270deg);transform:rotate(270deg)}.sk-fading-circle .sk-circle11{-webkit-transform:rotate(300deg);transform:rotate(300deg)}.sk-fading-circle .sk-circle12{-webkit-transform:rotate(330deg);transform:rotate(330deg)}.sk-fading-circle .sk-circle2:before{-webkit-animation-delay:-1.1s;animation-delay:-1.1s}.sk-fading-circle .sk-circle3:before{-webkit-animation-delay:-1s;animation-delay:-1s}.sk-fading-circle .sk-circle4:before{-webkit-animation-delay:-.9s;animation-delay:-.9s}.sk-fading-circle .sk-circle5:before{-webkit-animation-delay:-.8s;animation-delay:-.8s}.sk-fading-circle .sk-circle6:before{-webkit-animation-delay:-.7s;animation-delay:-.7s}.sk-fading-circle .sk-circle7:before{-webkit-animation-delay:-.6s;animation-delay:-.6s}.sk-fading-circle .sk-circle8:before{-webkit-animation-delay:-.5s;animation-delay:-.5s}.sk-fading-circle .sk-circle9:before{-webkit-animation-delay:-.4s;animation-delay:-.4s}.sk-fading-circle .sk-circle10:before{-webkit-animation-delay:-.3s;animation-delay:-.3s}.sk-fading-circle .sk-circle11:before{-webkit-animation-delay:-.2s;animation-delay:-.2s}.sk-fading-circle .sk-circle12:before{-webkit-animation-delay:-.1s;animation-delay:-.1s}@-webkit-keyframes sk-circleFadeDelay{0%,100%,39%{opacity:0}40%{opacity:1}}@keyframes sk-circleFadeDelay{0%,100%,39%{opacity:0}40%{opacity:1}}\"]\n            }] }\n];\n/** @nocollapse */\nAutocompleteComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 }\n];\nAutocompleteComponent.propDecorators = {\n    searchInput: [{ type: ViewChild, args: ['searchInput',] }],\n    filteredListElement: [{ type: ViewChild, args: ['filteredListElement',] }],\n    historyListElement: [{ type: ViewChild, args: ['historyListElement',] }],\n    data: [{ type: Input }],\n    searchKeyword: [{ type: Input }],\n    placeHolder: [{ type: Input }],\n    heading: [{ type: Input }],\n    initialValue: [{ type: Input }],\n    historyIdentifier: [{ type: Input }],\n    historyHeading: [{ type: Input }],\n    historyListMaxNumber: [{ type: Input }],\n    notFoundText: [{ type: Input }],\n    isLoading: [{ type: Input }],\n    debounceTime: [{ type: Input }],\n    disabled: [{ type: Input }],\n    minQueryLength: [{ type: Input }],\n    selected: [{ type: Output }],\n    inputChanged: [{ type: Output }],\n    inputFocused: [{ type: Output }],\n    inputCleared: [{ type: Output }],\n    opened: [{ type: Output }],\n    closed: [{ type: Output }],\n    scrolledToEnd: [{ type: Output }],\n    itemTemplate: [{ type: Input }],\n    notFoundTemplate: [{ type: Input }],\n    customTemplate: [{ type: ContentChild, args: [TemplateRef,] }]\n};\nif (false) {\n    /** @type {?} */\n    AutocompleteComponent.prototype.searchInput;\n    /** @type {?} */\n    AutocompleteComponent.prototype.filteredListElement;\n    /** @type {?} */\n    AutocompleteComponent.prototype.historyListElement;\n    /** @type {?} */\n    AutocompleteComponent.prototype.inputKeyUp$;\n    /** @type {?} */\n    AutocompleteComponent.prototype.inputKeyDown$;\n    /** @type {?} */\n    AutocompleteComponent.prototype.query;\n    /** @type {?} */\n    AutocompleteComponent.prototype.filteredList;\n    /** @type {?} */\n    AutocompleteComponent.prototype.historyList;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isHistoryListVisible;\n    /** @type {?} */\n    AutocompleteComponent.prototype.elementRef;\n    /** @type {?} */\n    AutocompleteComponent.prototype.selectedIdx;\n    /** @type {?} */\n    AutocompleteComponent.prototype.toHighlight;\n    /** @type {?} */\n    AutocompleteComponent.prototype.notFound;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isFocused;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isOpen;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isScrollToEnd;\n    /** @type {?} */\n    AutocompleteComponent.prototype.overlay;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutocompleteComponent.prototype.manualOpen;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutocompleteComponent.prototype.manualClose;\n    /**\n     * Data of items list.\n     * It can be array of strings or array of objects.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.data;\n    /** @type {?} */\n    AutocompleteComponent.prototype.searchKeyword;\n    /** @type {?} */\n    AutocompleteComponent.prototype.placeHolder;\n    /** @type {?} */\n    AutocompleteComponent.prototype.heading;\n    /** @type {?} */\n    AutocompleteComponent.prototype.initialValue;\n    /**\n     * History identifier of history list\n     * When valid history identifier is given, then component stores selected item to local storage of user's browser.\n     * If it is null then history is hidden.\n     * History list is visible if at least one history item is stored.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.historyIdentifier;\n    /**\n     * Heading text of history list.\n     * If it is null then history heading is hidden.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.historyHeading;\n    /** @type {?} */\n    AutocompleteComponent.prototype.historyListMaxNumber;\n    /** @type {?} */\n    AutocompleteComponent.prototype.notFoundText;\n    /** @type {?} */\n    AutocompleteComponent.prototype.isLoading;\n    /** @type {?} */\n    AutocompleteComponent.prototype.debounceTime;\n    /** @type {?} */\n    AutocompleteComponent.prototype.disabled;\n    /**\n     * The minimum number of characters the user must type before a search is performed.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.minQueryLength;\n    /**\n     * Event that is emitted whenever an item from the list is selected.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.selected;\n    /**\n     * Event that is emitted whenever an input is changed.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.inputChanged;\n    /**\n     * Event that is emitted whenever an input is focused.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.inputFocused;\n    /**\n     * Event that is emitted whenever an input is cleared.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.inputCleared;\n    /**\n     * Event that is emitted when the autocomplete panel is opened.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.opened;\n    /**\n     * Event that is emitted when the autocomplete panel is closed.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.closed;\n    /**\n     * Event that is emitted when scrolled to the end of items.\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.scrolledToEnd;\n    /** @type {?} */\n    AutocompleteComponent.prototype.itemTemplate;\n    /** @type {?} */\n    AutocompleteComponent.prototype.notFoundTemplate;\n    /** @type {?} */\n    AutocompleteComponent.prototype.customTemplate;\n    /**\n     * Propagates new value when model changes\n     * @type {?}\n     */\n    AutocompleteComponent.prototype.propagateChange;\n    /**\n     * @type {?}\n     * @private\n     */\n    AutocompleteComponent.prototype.renderer;\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete/highlight.pipe.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass HighlightPipe {\n    /**\n     * @param {?} text\n     * @param {?} search\n     * @param {?=} searchKeyword\n     * @return {?}\n     */\n    transform(text, search, searchKeyword) {\n        /** @type {?} */\n        let pattern = search.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n        pattern = pattern.split(' ').filter((/**\n         * @param {?} t\n         * @return {?}\n         */\n        (t) => {\n            return t.length > 0;\n        })).join('|');\n        /** @type {?} */\n        const regex = new RegExp(pattern, 'gi');\n        if (!search) {\n            return text;\n        }\n        if (searchKeyword) {\n            /** @type {?} */\n            const name = text[searchKeyword].replace(regex, (/**\n             * @param {?} match\n             * @return {?}\n             */\n            (match) => `<b>${match}</b>`));\n            // copy original object\n            /** @type {?} */\n            const text2 = Object.assign({}, text);\n            // set bold value into searchKeyword of copied object\n            text2[searchKeyword] = name;\n            return text2;\n        }\n        else {\n            return search ? text.replace(regex, (/**\n             * @param {?} match\n             * @return {?}\n             */\n            (match) => `<b>${match}</b>`)) : text;\n        }\n    }\n}\nHighlightPipe.decorators = [\n    { type: Pipe, args: [{\n                name: 'highlight'\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/autocomplete-lib.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AutocompleteLibModule {\n}\nAutocompleteLibModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [\n                    CommonModule,\n                    FormsModule\n                ],\n                declarations: [AutocompleteLibComponent, AutocompleteComponent, HighlightPipe],\n                exports: [AutocompleteLibComponent, AutocompleteComponent, HighlightPipe]\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: angular-ng-autocomplete.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { AutocompleteComponent, AutocompleteLibComponent, AutocompleteLibModule, HighlightPipe };\n"]}